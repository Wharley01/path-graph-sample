## Live Controller

Path introduces a new approach to making a two-way real-time communication between the client-side and the server-side, wait, breath in, now out, lol, this is actually a very straightforward concept, it's basically you creating a class Called `Live Controller` that must extend an abstract class `Path\Core\Router\Live\Controller` in `path/Controllers/Live` folder with namespace `Path\App\Controllers\Live` and adding properties or methods then listen/watch for changes in your Live Controller Class's property's value or method's returned value from the client side, an example below shows how a super simple `Live Controller` Class looks like.

```php
<?php

/*
* This Live Controller File Was automatically 
* Generated by Path
* Modify to Suite your needs,
* */

namespace Path\App\Controllers\Live;

use Path\Core\Http\Response;
use Path\Core\Http\Watcher\WatcherInterface;
use Path\Core\Router\Live\Controller;
use Path\Core\Storage\Sessions;

class TestChanges extends Controller
{

    public $prop;


    //every time the watcher checks this Live Controller, it passes some data to it
    public function __construct(
        WatcherInterface  &$watcher,//watcher instance
        Sessions $sessions //the session instance that can be used for auth. with the client side
    )
    {

        $this->prop =  $sessions->get('is_logged_in') ? 'yes':'no';
    }
    public function prop(
        Response $response,
        WatcherInterface  &$watcher,
        Sessions $sessions
    ){
//response here will be sent to client side when $this->prop's value changes
        return $this->prop;
    }
    public function onMessage(
        WatcherInterface  &$watcher,
        Sessions $sessions
    ){
        //  this fires when there is a message from Client side(probably javascript?)
    }

    public function onConnect(
        WatcherInterface  &$watcher,
        Sessions $sessions
    ){

    }

    public function onClose(
        WatcherInterface &$watcher,
        Sessions $sessions,
        ?String  $message
    ){

    }
}
```

#### Code explanation

`On line 8` we declared this class's namespace to be the standard namespace for Live controller as mentioned earlier.

`On line 15` We named our `Live Controller` to be TestChanges.

`On line 18` we declared a property $prop to be populated later in the class's constructor and watched from the client side.

`On line 22` we have our constructor with parameters we are expecting from Path.

`On line 29` we populated the earlier created property `$prop` with yes/no based on the value of session `is_logged_in`

`On line 32` we have a method with the same name as our property `$prop`, this means we want to use this method's returned value for this property($prop) when the property($prop) changes; the value that will be sent to the client will be `prop()` method's returned value.

`On line 40` has an `onMessage` method which runs when there is a message from the client side.

`On line 48` also has another hook namely `onConnect` method which runs when the client-server connection is done successfully.

`On line 56` we have `onClose` method which runs when the connection is closed.

```
You can let Path create this Live Controller boilerplate code for you by using the command `php __path create controller yourControllerName` then choose 'Live' when asked the type of controller you are willing to create.
```

### The WatcherInterface instance

You probably saw `WatcherInterface &$watcher` in the example above and wondered what it does? `WatcherInterface` gives you access to info from [@__path/watcher javascript library](#Client-Side-integration). below is the list of the available list of methods you have access to:

| Method | Description|
|:-------|:------------|
| getMessage():?String |  Returns Message sent from client side or null if there is no message|
| getParams($key = null) | get parameter set to [@__path/watcher](#Client-Side-integration)|
| close():void | Close Connection |

### Client Side integration

After Setting up your Live Controller class on the server side, the next thing would be communication with it from the client side, this can be done using the [@__path/watcher](https://www.npmjs.com/package/@__path/watcher) javascript library, below is an example showing steps to communicate with or listen to the Live Controller class we created earlier:

```javascript
import Watcher from "@__path/watcher";

let watcher =  new Watcher('TestChanges')
//here we are referencing the class we created earlier
                   .watch('prop')//we told path-watcher which of the properties to watch, this case we are watching $prop property
                   .setParams({
                       key1:'a value',
                       anotherKey:'another value'
                   })//we are adding additional infos that can be retrieved from the server side with `getParam()` method of WatcherInterface instance.
watcher.onReady(watcher => {
    // here, we can assign functions to be executed when a particular property changes
    watcher.listenTo("prop", response => {
// we assign an anonymous function to execute when $prop changes on server side
//the `response` parameter will be an object where key "data" will be our property's value

        let is_logged_in = response.data;
// extract the data 
        if(is_logged_in !== 'yes'){
            location.href = '/logout'
        }
    })
})
watcher.start();//tell path to begin watching


```

The code above is well commented, if you need more information on this, quickly head to [its documentation](https://www.npmjs.com/package/@__path/watcher) on npm website, it contains the installation guide and usage.
